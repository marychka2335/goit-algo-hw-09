Вы
домашнє завдання до теми “Жадібні алгоритми та динамічне програмування”! 🙂

Вивчення жадібних алгоритмів та алгоритмів динамічного програмування разом із практичним досвідом розв'язання завдань допоможе вам покращити свою майстерність у сфері оптимізації та аналізу алгоритмів.

Під час виконання цього домашнього завдання:

ви зможете поглибити свої знання та розуміння в реалізації жадібних алгоритмів та алгоритмів динамічного програмування;
отримаєте можливість застосувати теоретичні знання на практиці: розробка функцій жадібного алгоритму та алгоритму динамічного програмування дозволить вам легше розуміти їхню реальну природу та застосування;
через порівняння ефективності двох різних методів розв’язання одного завдання ви навчитесь проводити об'єктивний аналіз та розуміти, який метод може бути ефективнішим у конкретних умовах.

У конспекті ми розглянули приклад про розбиття суми на монети. Маємо набір монет [50, 25, 10, 5, 2, 1]. Уявіть, що ви розробляєте систему для касового апарату, яка повинна визначити оптимальний спосіб видачі решти покупцеві.

Вам необхідно написати дві функції для касової системи, яка видає решту покупцеві:

Функція жадібного алгоритму find_coins_greedy. Ця функція повинна приймати суму, яку потрібно видати покупцеві, і повертати словник із кількістю монет кожного номіналу, що використовуються для формування цієї суми. Наприклад, для суми 113 це буде словник {50: 2, 10: 1, 2: 1, 1: 1}. Алгоритм повинен бути жадібним, тобто спочатку вибирати найбільш доступні номінали монет.
Функція динамічного програмування find_min_coins. Ця функція також повинна приймати суму для видачі решти, але використовувати метод динамічного програмування, щоб знайти мінімальну кількість монет, необхідних для формування цієї суми. Функція повинна повертати словник із номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом. Наприклад, для суми 113 це буде словник {1: 1, 2: 1, 10: 1, 50: 2}
Порівняйте ефективність жадібного алгоритму та алгоритму динамічного програмування, базуючись на часі їх виконання або О великому та звертаючи увагу на їхню продуктивність при великих сумах. Висвітліть, як вони справляються з великими сумами та чому один алгоритм може бути більш ефективним за інший у певних ситуаціях. Свої висновки додайте у файл readme.md домашнього завдання.
Вимоги:
Програмно реалізовано функцію, яка використовує принцип жадібного алгоритму. Код виконується і повертає словник з кількістю монет кожного номіналу, що використовуються для формування певної суми. Спочатку вибираються найбільш доступні номінали монет.
Програмно реалізовано функцію, яка використовує принцип динамічного програмування. Код виконується і повертає словник з номіналами монет та їх кількістю для досягнення заданої суми найефективнішим способом.
На основі оцінювання часу виконання кожного з двох алгоритмів або О великого визначено найбільш ефективний при великих сумах алгоритм.
Зроблено висновки щодо ефективності алгоритмів для даного випадку. 

Перевір відповідність коду вимогам та завданню, оптимізуй за потребою:

import timeit

coins = [50, 25, 10, 5, 2, 1]

#Функція жадібного алгоритму для касової системи, яка видає решту покупцеві
def find_coins_greedy(amount):
    result = {}
    for coin in coins:
        if amount >= coin:
            result[coin] = amount // coin
            amount = amount % coin
    return result

print(f"Жадібний алгоритм: ",find_coins_greedy(113))  # {50: 2, 10: 1, 2: 1, 1: 1}


#Функція динамічного програмування для касової системи, яка видає решту покупцеві
def find_min_coins(amount):
    # Ініціалізація таблиці для зберігання мінімальної кількості монет для кожної суми
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Для суми 0 потрібно 0 монет

    # Таблиця для зберігання використаних монет
    coin_used = [-1] * (amount + 1)

    # Заповнення таблиці dp
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin and dp[i - coin] + 1 < dp[i]:
                dp[i] = dp[i - coin] + 1
                coin_used[i] = coin

    # Якщо сума не може бути сформована з доступних монет
    if dp[amount] == float('inf'):
        return {}

    # Відновлення використаних монет
    result = {}
    i = amount
    while i > 0:
        coin = coin_used[i]
        if coin in result:
            result[coin] += 1
        else:
            result[coin] = 1
        i -= coin

    return result


print(f"Динамічне програмування: ", find_min_coins(113))  # {50: 2, 10: 1, 2: 1, 1: 1}

# Порівняння часу виконання жадібного алгоритму та динамічного програмування
amounts = [15, 60, 113, 129, 130, 200, 500, 999, 1005]
results = []

for amount in amounts:
    time_greedy = timeit.timeit(lambda: find_coins_greedy(amount), number=1000)
    time_dp = timeit.timeit(lambda: find_min_coins(amount), number=1000)
    results.append([amount, time_greedy, time_dp])

print("| Amount | Greedy Time (s) | DP Time (s) |")
print("|--------|-----------------|-------------|")
for result in results:
    print(f"| {result[0]:>6} | {result[1]:>15.8f} | {result[2]:>11.8f} |")
Copilot
Цей код виглядає загалом добре, але є кілька оптимізацій, які можна внести для покращення читабельності та продуктивності. Ось оновлений код:

python

Копировать
import timeit

coins = [50, 25, 10, 5, 2, 1]

# Функція жадібного алгоритму для касової системи, яка видає решту покупцеві
def find_coins_greedy(amount):
    result = {}
    for coin in coins:
        if amount >= coin:
            result[coin] = amount // coin
            amount = amount % coin
    return result

print("Жадібний алгоритм:", find_coins_greedy(113))  # {50: 2, 10: 1, 2: 1, 1: 1}

# Функція динамічного програмування для касової системи, яка видає решту покупцеві
def find_min_coins(amount):
    # Ініціалізація таблиці для зберігання мінімальної кількості монет для кожної суми
    dp = [float('inf')] * (amount + 1)
    dp[0] = 0  # Для суми 0 потрібно 0 монет
    # Таблиця для зберігання використаних монет
    coin_used = [-1] * (amount + 1)
    # Заповнення таблиці dp
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin and dp[i - coin] + 1 < dp[i]:
                dp[i] = dp[i - coin] + 1
                coin_used[i] = coin
    # Якщо сума не може бути сформована з доступних монет
    if dp[amount] == float('inf'):
        return {}
    # Відновлення використаних монет
    result = {}
    i = amount
    while i > 0:
        coin = coin_used[i]
        if coin in result:
            result[coin] += 1
        else:
            result[coin] = 1
        i -= coin
    return result

print("Динамічне програмування:", find_min_coins(113))  # {50: 2, 10: 1, 2: 1, 1: 1}

# Порівняння часу виконання жадібного алгоритму та динамічного програмування
amounts = [15, 60, 113, 129, 130, 200, 500, 999, 1005]
results = []

for amount in amounts:
    time_greedy = timeit.timeit(lambda: find_coins_greedy(amount), number=1000)
    time_dp = timeit.timeit(lambda: find_min_coins(amount), number=1000)
    results.append([amount, time_greedy, time_dp])

print("| Amount | Greedy Time (s) | DP Time (s) |")
print("|--------|-----------------|-------------|")
for result in results:
    print(f"| {result[0]:>6} | {result[1]:>15.8f} | {result[2]:>11.8f} |")
Висновки щодо ефективності алгоритмів
Жадібний алгоритм
Жадібний алгоритм швидко працює, вибираючи найбільші номінали монет першими. Він є дуже ефективним для великих сум у випадках, коли набір монет забезпечує оптимальне розв'язання, як у цьому завданні. Для кожної суми його час виконання є сталим 
O
(
n
)
, де 
n
 — кількість номіналів монет.

Алгоритм динамічного програмування
Алгоритм динамічного програмування гарантує оптимальне розв'язання, знаходячи мінімальну кількість монет для даної суми. Він вимагає більших обчислювальних ресурсів і часу виконання, оскільки використовує таблицю для збереження мінімальних значень для кожної суми від 0 до заданої. Його час виконання становить 
O
(
m
⋅
n
)
, де 
m
 — сума, 
n
 — кількість номіналів монет.

Порівняння
Результати показують, що для великих сум жадібний алгоритм є швидшим, тоді як алгоритм динамічного програмування забезпечує найефективніше розв'язання (мінімальна кількість монет). Жадібний алгоритм може бути менш ефективним, якщо набір монет не дозволяє легко знайти оптимальне розв'язання. У таких випадках алгоритм динамічного програмування є надійним інструментом.